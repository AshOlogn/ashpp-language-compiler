This file just contains notes I periodically take as part of the brainstorming
process and is roughly divided into the different sections of compilation, with
each section elaborating on design decisions, etc.

This document will be changed arbitrarily and isn't a formal record of my work
on the compiler. Once I'm done, I'll make a formal write-up of

Lexer
  - Read a .app file into a string
  - Convert the file into a list of tokens (variant type)
      - token type
      - attributes
      - line number range (for debugging)

Grammar
In this language, I need a mini-grammar to express types (denoted by T), so that recursive types like
arrays, functions, etc. can be properly supported. In the original Ash language, these
things were hard-coded and extremely clunky.

The following describes the grammar of my language. Comments are denoted on the side with -- 
(gotta love Haskell-style) and aren't a part of the grammar.

S - statement
E - expression

S =   if E S else S 
    | while E S
    | T id = E        -- variable declaration with type
    | id = E          -- variable assignment

Expressions listed from lowest to highest precedence
E =   E1 +- E1         -- view this as a string of operations (so E1+E1+...), avoids left-recursion
    | E1

E1 =  E2 */ E2
    | E2

E2 =  '(' E ')'       -- parenthesized expressions   
    | number          -- literal numbers


Type grammar
T =   [T]             -- array of a type
    | (T...T)         -- n-tuple
    | T -> T          -- function
    | className       -- class name 
    | primitives      -- int, double, char, etc.
